//@version=6
// ===== CHOOSE ONE of the two 'indicator(...)' lines (comment the other) =====
// ---- A) Overlay on price as a bottom band
indicator("Go + Rotation HUD (Trend + Rotation) — v6", overlay=true, max_labels_count=50, max_lines_count=50)
// ---- B) Separate panel version (place in its own pane below)
// indicator("Go + Rotation HUD (Trend + Rotation) — v6 (panel)", overlay=false, max_labels_count=50, max_lines_count=50)

// ─────────────────────────────────────────────────────────────────────────────
// Inputs
groupGates  = "Windows / Gates"
groupWeight = "Feature Weights"
groupTh     = "Thresholds"
groupDisp   = "Display"

goThresh  = input.int(70,  "Green ≥",   group=groupTh, minval=0, maxval=100)
yellowMin = input.int(60,  "Yellow ≥",  group=groupTh, minval=0, maxval=100)

lenRV     = input.int(20,  "RVol length",     group=groupWeight, minval=2)
lenUD     = input.int(10,  "U/D smooth",      group=groupWeight, minval=1)
lenADX    = input.int(14,  "ADX length",      group=groupWeight, minval=2)
lenChop   = input.int(14,  "Chop length",     group=groupWeight, minval=2)
emaFast   = input.int(8,   "EMA fast",        group=groupWeight, minval=1)
emaSlow   = input.int(24,  "EMA slow",        group=groupWeight, minval=2)
wRV       = input.float(1.0, "w_RVol",        group=groupWeight, minval=0)
wUD       = input.float(1.0, "w_U/D",         group=groupWeight, minval=0)
wADX      = input.float(0.8, "w_ADX/DI",      group=groupWeight, minval=0)
wChop     = input.float(0.6, "w_Chop",        group=groupWeight, minval=0)
wVWAP     = input.float(0.9, "w_VWAP pos",    group=groupWeight, minval=0)
wReg      = input.float(0.8, "w_Regime",      group=groupWeight, minval=0)

showRotationRow = input.bool(true, "Show Rotation row", group=groupDisp)
txtScale        = input.string("Small", "Text size", options=["Tiny","Small","Large","Huge"], group=groupDisp)

// ─────────────────────────────────────────────────────────────────────────────
// Helpers
clamp(x, lo, hi) => math.max(lo, math.min(hi, x))

txtSize(s) =>
    // return a built-in size enum from a string
    out = size.normal
    if s == "Tiny"
        out := size.tiny
    else if s == "Small"
        out := size.small
    else if s == "Large"
        out := size.large
    else if s == "Huge"
        out := size.huge
    out

tileColorFromScore(score) =>
    c = color.rgb(165, 42, 42)                    // default brown-red
    if score >= goThresh
        c := color.new(color.lime, 0)
    else if score >= yellowMin
        c := color.new(color.gold, 0)
    c

// ─────────────────────────────────────────────────────────────────────────────
// Trend features

// Relative Volume
rvSma  = ta.sma(volume, lenRV)
rv     = na(rvSma) or rvSma == 0 ? 1.0 : volume / rvSma
sRVol  = clamp((rv - 1.0), -1.0, 1.0)

// Up/Down pressure
udRaw  = math.sign(close - close[1])
udAvg  = ta.sma(udRaw, lenUD)
sUD    = clamp(udAvg, -1.0, 1.0)

// ADX / DI alignment (v6 names)
adx    = ta.adx(lenADX)
plusDI = ta.plusdi(lenADX)
minusDI= ta.minusdi(lenADX)
dir    = plusDI >= minusDI ? 1.0 : -1.0
sADX   = clamp((adx / 30.0) * dir, -1.0, 1.0)

// Choppiness Index (classic)
trueRangeSum = ta.rma(ta.tr, lenChop) * lenChop
hh = ta.highest(high, lenChop)
ll = ta.lowest(low, lenChop)
den = math.max(hh - ll, syminfo.mintick)
chop = 100.0 * math.log10(trueRangeSum / den) / math.log10(lenChop)
sChopTrend = clamp((50.0 - (chop - 50.0)) / 50.0, -1.0, 1.0)  // trend likes low chop

// VWAP position
vwap = ta.vwap
sVWAP = close >= vwap ? 0.5 : -0.5

// Regime (EMA slope/position)
emaF = ta.ema(close, emaFast)
emaS = ta.ema(close, emaSlow)
slope = emaF - emaS
posE  = (close - emaS) / math.max(ta.atr(14), syminfo.mintick)
sReg  = clamp(0.6 * math.sign(posE) + 0.4 * math.sign(slope), -1.0, 1.0)

// Weighted probability 0..100
zTrend = wRV * sRVol + wUD * sUD + wADX * sADX + wChop * sChopTrend + wVWAP * sVWAP + wReg * sReg
pTrend = 50.0 + 50.0 * clamp(zTrend / (wRV + wUD + wADX + wChop + wVWAP + wReg), -1.0, 1.0)

// ─────────────────────────────────────────────────────────────────────────────
// Rotation features (simple)
sChopRot = clamp((chop - 50.0) / 50.0, -1.0, 1.0)                  // rotation likes high chop
sADXRot  = clamp((20.0 - adx) / 20.0, -1.0, 1.0)                   // lower ADX better
sVWAPRot = 1.0 - math.min(math.abs(close - vwap) / (3.0*ta.atr(14)), 1.0)  // near vwap → 1

zRot = wChop * sChopRot + wADX * sADXRot + wVWAP * sVWAPRot
pRot = 50.0 + 50.0 * clamp(zRot / (wChop + wADX + wVWAP), -1.0, 1.0)

// ─────────────────────────────────────────────────────────────────────────────
// Table HUD at bottom (overlay) or inside panel
cols = showRotationRow ? 7 : 3
rows = 2
var tbl = table.new(position.bottom_center, columns=cols, rows=rows, frame_color=color.new(color.gray,70), frame_width=1)

setHdr(row, col, txt) =>
    table.cell(tbl, row, col, txt, text_color=color.white, bgcolor=color.new(color.black, 0), text_size=txtSize(txtScale))

putTile(row, col, label, score, note) =>
    c = tileColorFromScore(score)
    table.cell(tbl, row-1, col, label, text_color=color.silver, bgcolor=color.new(color.black,0), text_size=txtSize(txtScale))
    table.cell(tbl, row,   col, label + "\n" + note, text_color=color.black, bgcolor=c, text_size=txtSize(txtScale))
    col + 1

if barstate.islast
    table.clear(tbl, 0, 0, cols-1, rows-1) // v6 requires bounds

    col = 0
    col := putTile(1, col, "GO",   pTrend, "GO " + str.tostring(math.round(pTrend)) + "%")
    col := putTile(1, col, "RVol", 50 + 50*clamp(sRVol,-1,1),   "rv="  + str.tostring(rv, format.mintick))
    col := putTile(1, col, "U/D",  50 + 50*clamp(sUD, -1,1),    "ud="  + str.tostring(udAvg, format.mintick))
    col := putTile(1, col, "ADX",  50 + 50*clamp(sADX,-1,1),    "adx=" + str.tostring(adx, format.mintick))
    col := putTile(1, col, "Chop", 50 + 50*clamp(sChopTrend,-1,1), "ci=" + str.tostring(chop, format.mintick))
    col := putTile(1, col, "VWAP", 50 + 50*clamp(sVWAP,-1,1),   "Δ="   + str.tostring(close - vwap, format.mintick))
    col := putTile(1, col, "Reg",  50 + 50*clamp(sReg,-1,1),    "pos=" + str.tostring(posE, format.mintick))

    if showRotationRow
        col2 = 0
        col2 := putTile(1, col2, "ROT",  pRot,  "ROT " + str.tostring(math.round(pRot)) + "%")
        col2 := putTile(1, col2, "Chop", 50 + 50*clamp(sChopRot,-1,1), "ci=" + str.tostring(chop, format.mintick))
        col2 := putTile(1, col2, "ADX",  50 + 50*clamp(sADXRot,-1,1),  "adx=" + str.tostring(adx, format.mintick))
        col2 := putTile(1, col2, "VWAP", 50 + 50*clamp(sVWAPRot,-1,1), "Δ="   + str.tostring(close - vwap, format.mintick))

// ─────────────────────────────────────────────────────────────────────────────
// Optional alerts
doTrendAlert = input.bool(false, "Alert: GO turns green", group=groupDisp)
doRotAlert   = input.bool(false, "Alert: ROT turns green", group=groupDisp)

trendGo = ta.crossover(pTrend, goThresh)
rotGo   = ta.crossover(pRot,   goThresh)
if doTrendAlert and trendGo
    alert("GO (trend) crossed ≥ " + str.tostring(goThresh) + "%", alert.freq_once_per_bar_close)
if doRotAlert and rotGo
    alert("ROT (rotation) crossed ≥ " + str.tostring(goThresh) + "%", alert.freq_once_per_bar_close)
