#region Using
using System;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Windows.Media;
using NinjaTrader.Data;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.DrawingTools;
using NinjaTrader.NinjaScript.Indicators;
#endregion

namespace NinjaTrader.NinjaScript.Indicators
{
    public class RotationHUD : Indicator
    {
        // ---------- Parameters: Gates ----------
        [NinjaScriptProperty, Range(5, 100)]
        [Display(Name = "Chop Length", GroupName = "Gates", Order = 0)]
        public int ChopLen { get; set; } = 14;

        [NinjaScriptProperty, Range(1, 100)]
        [Display(Name = "Chop Min (rotation if ≥)", GroupName = "Gates", Order = 1)]
        public int ChopMin { get; set; } = 60;

        [NinjaScriptProperty, Range(5, 100)]
        [Display(Name = "ADX Length", GroupName = "Gates", Order = 2)]
        public int AdxLen { get; set; } = 14;

        [NinjaScriptProperty, Range(1, 100)]
        [Display(Name = "ADX Max (rotation if ≤)", GroupName = "Gates", Order = 3)]
        public int AdxMax { get; set; } = 18;

        [NinjaScriptProperty, Range(10, 400)]
        [Display(Name = "Regression Window (bars)", GroupName = "Gates", Order = 4)]
        public int RegrWin { get; set; } = 60;

        // ---------- VA Source ----------
        [NinjaScriptProperty]
        [Display(Name = "Use Manual VA (type VAH/VAL/POC)", GroupName = "Value Area", Order = 10)]
        public bool UseManualVA { get; set; } = false;

        [NinjaScriptProperty]
        [Display(Name = "Manual VAH", GroupName = "Value Area", Order = 11)]
        public double ManualVAH { get; set; } = 0;

        [NinjaScriptProperty]
        [Display(Name = "Manual VAL", GroupName = "Value Area", Order = 12)]
        public double ManualVAL { get; set; } = 0;

        [NinjaScriptProperty]
        [Display(Name = "Manual POC", GroupName = "Value Area", Order = 13)]
        public double ManualPOC { get; set; } = 0;

        // Proxy if not using manual: VWAP ± k·σ of typical price
        [NinjaScriptProperty, Range(0.5, 3.0)]
        [Display(Name = "Proxy k (VWAP ± k·σ)", GroupName = "Value Area", Order = 14)]
        public double VAProxyK { get; set; } = 1.35;

        [NinjaScriptProperty, Range(20, 400)]
        [Display(Name = "Proxy σ Length", GroupName = "Value Area", Order = 15)]
        public int VAProxyLen { get; set; } = 120;

        // ---------- IB (Initial Balance) ----------
        [NinjaScriptProperty]
        [Display(Name = "IB Start (HH:mm)", GroupName = "Initial Balance", Order = 20)]
        public string IBStartStr { get; set; } = "09:30";

        [NinjaScriptProperty]
        [Display(Name = "IB End (HH:mm)", GroupName = "Initial Balance", Order = 21)]
        public string IBEndStr { get; set; } = "10:00";

        // ---------- Scoring / Colors ----------
        [NinjaScriptProperty, Range(0, 100)]
        [Display(Name = "Weight: Regime", GroupName = "Scoring", Order = 30)]
        public int WRegime { get; set; } = 35;

        [NinjaScriptProperty, Range(0, 100)]
        [Display(Name = "Weight: Location", GroupName = "Scoring", Order = 31)]
        public int WLocation { get; set; } = 45;

        [NinjaScriptProperty, Range(0, 100)]
        [Display(Name = "Weight: Bias", GroupName = "Scoring", Order = 32)]
        public int WBias { get; set; } = 20;

        [NinjaScriptProperty, Range(0, 100)]
        [Display(Name = "Green ≥", GroupName = "Scoring", Order = 33)]
        public int GreenMin { get; set; } = 75;

        [NinjaScriptProperty, Range(0, 100)]
        [Display(Name = "Yellow ≥ (else Red)", GroupName = "Scoring", Order = 34)]
        public int YellowMin { get; set; } = 60;

        [NinjaScriptProperty]
        [Display(Name = "Badge Position", GroupName = "Visual", Order = 40)]
        public TextPosition BadgePosition { get; set; } = TextPosition.TopLeft;

        [NinjaScriptProperty]
        [Display(Name = "Show Lines (VA/POC/IB/Reg)", GroupName = "Visual", Order = 41)]
        public bool ShowLines { get; set; } = true;

        // ---------- Internals ----------
        private ChoppinessIndex ci;
        private ADX adx;

        private Series<double> typ;
        private StdDev typStd;
        private Series<double> vwap;
        private double cumPV, cumVol;

        private SimpleFont font;
        private DateTime curDay = DateTime.MinValue;
        private DateTime ibStart, ibEnd;
        private double vah, val, poc;

        // Regression stats
        private double regrCenter, regrSlope, regrSD;

        // Brushes
        private Brush badgeGreen = Brushes.LimeGreen;
        private Brush badgeYellow = Brushes.Goldenrod;
        private Brush badgeRed = Brushes.IndianRed;
        private Brush textBrush = Brushes.White;

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "RotationHUD (v0)";
                IsOverlay = true;
                Calculate = Calculate.OnBarClose;
                DrawOnPricePanel = true;
            }
            else if (State == State.Configure)
                font = new SimpleFont("Segoe UI", 13) { Bold = true };
            else if (State == State.DataLoaded)
            {
                ci = ChoppinessIndex(ChopLen);
                adx = ADX(AdxLen);

                typ = new Series<double>(this);
                typStd = StdDev(typ, VAProxyLen);

                vwap = new Series<double>(this);
            }
        }

        protected override void OnBarUpdate()
        {
            if (CurrentBar < Math.Max(Math.Max(ChopLen, AdxLen), VAProxyLen))
                return;

            DateTime d = Times[0][0].Date;
            if (d != curDay)
            {
                curDay = d;
                ParseIBTimes();
            }

            typ[0] = (High[0] + Low[0] + Close[0]) / 3.0;

            if (Bars.IsFirstBarOfSession)
            {
                cumPV = 0;
                cumVol = 0;
            }
            cumPV += typ[0] * Volume[0];
            cumVol += Volume[0];
            vwap[0] = cumVol != 0 ? cumPV / cumVol : typ[0];

            if (UseManualVA && ManualVAH > 0 && ManualVAL > 0 && ManualPOC > 0)
            {
                vah = ManualVAH;
                val = ManualVAL;
                poc = ManualPOC;
            }
            else
            {
                double sigma = typStd[0];
                double vwapNow = vwap[0];
                poc = vwapNow;
                vah = vwapNow + VAProxyK * sigma;
                val = vwapNow - VAProxyK * sigma;
            }

            ComputeRegression(RegrWin, out regrCenter, out regrSlope, out regrSD);
            double rail2u = regrCenter + 2.0 * regrSD;
            double rail2l = regrCenter - 2.0 * regrSD;

            double sReg = 0;
            if (ci[0] >= ChopMin) sReg += 20;
            if (adx[0] <= AdxMax || (adx[0] < adx[1] && adx[1] < adx[2])) sReg += 15;

            bool nearVAH = Math.Abs(Close[0] - vah) <= TickSize * 4;
            bool nearVAL = Math.Abs(Close[0] - val) <= TickSize * 4;
            bool onEdge = nearVAH || nearVAL || Close[0] >= rail2u || Close[0] <= rail2l;
            bool conflUp = nearVAH && Math.Abs(vah - rail2u) <= TickSize * 2;
            bool conflDown = nearVAL && Math.Abs(val - rail2l) <= TickSize * 2;

            double sLoc = 0;
            if (onEdge) sLoc += 30;
            if (conflUp || conflDown) sLoc += 15;

            double ibH = IBHigh();
            double ibL = IBLow();
            bool meanInIB = (!double.IsNaN(ibH) && !double.IsNaN(ibL) && poc <= ibH && poc >= ibL);
            bool slopeFlat = Math.Abs(regrSlope) <= TickSize * 0.25;

            double sBias = 0;
            if (meanInIB) sBias += 10;
            if (slopeFlat) sBias += 10;

            double wSum = WRegime + WLocation + WBias;
            if (wSum <= 0) wSum = 1;
            double score = (sReg * WRegime + sLoc * WLocation + sBias * WBias) / wSum;

            double z = regrSD > 0 ? (Close[0] - regrCenter) / regrSD : 0;
            if (Math.Abs(z) < 0.33) score = Math.Min(score, YellowMin - 1);
            if (Math.Abs(regrSlope) > TickSize) score = Math.Min(score, YellowMin - 1);

            Brush badge = badgeRed;
            string mode = "NO-GO";
            if (score >= GreenMin) { badge = badgeGreen; mode = "ROTATION"; }
            else if (score >= YellowMin) { badge = badgeYellow; mode = "CAUTION"; }

            string side;
            if (nearVAH) side = "Fade Short @ VAH";
            else if (nearVAL) side = "Fade Long  @ VAL";
            else if (Close[0] >= rail2u) side = "Fade Short @ +2σ";
            else if (Close[0] <= rail2l) side = "Fade Long  @ -2σ";
            else side = "Wait @ Mid";

            string text =
                $"{mode}  {score:0}%\n" +
                $"CI {ci[0]:0}  ADX {adx[0]:0}\n" +
                $"VAH {vah:0.00}  POC {poc:0.00}  VAL {val:0.00}\n" +
                $"{side}";

            Draw.TextFixed(
                this,
                "rot_badge",
                text,
                BadgePosition,
                textBrush,
                font,
                badge,
                Brushes.Black,
                80
            );

            if (ShowLines)
            {
                string dtag = curDay.ToString("yyyyMMdd");

                Draw.HorizontalLine(this, "VAH_" + dtag, vah, Brushes.ForestGreen);
                Draw.HorizontalLine(this, "VAL_" + dtag, val, Brushes.IndianRed);
                Draw.HorizontalLine(this, "POC_" + dtag, poc, Brushes.Goldenrod);

                if (!double.IsNaN(ibH))
                    Draw.HorizontalLine(this, "IBH_" + dtag, ibH, Brushes.SteelBlue);
                if (!double.IsNaN(ibL))
                    Draw.HorizontalLine(this, "IBL_" + dtag, ibL, Brushes.SteelBlue);

                Draw.HorizontalLine(this, "R2U_" + dtag, rail2u, Brushes.DimGray);
                Draw.HorizontalLine(this, "R2L_" + dtag, rail2l, Brushes.DimGray);
            }
        }

        // -------- Helpers --------
        private void ParseIBTimes()
        {
            DateTime t0 = Times[0][0].Date;
            TimeSpan s = TimeSpan.Parse(IBStartStr);
            TimeSpan e = TimeSpan.Parse(IBEndStr);
            ibStart = t0 + s;
            ibEnd = t0 + e;
        }

        private double IBHigh()
        {
            double h = double.MinValue;
            int n = Math.Min(CurrentBar + 1, 5000);
            for (int i = 0; i < n; i++)
            {
                DateTime t = Times[0][i];
                if (t >= ibStart && t <= ibEnd)
                    h = Math.Max(h, High[i]);
                if (t < ibStart.AddMinutes(-90)) break;
            }
            return h == double.MinValue ? double.NaN : h;
        }

        private double IBLow()
        {
            double l = double.MaxValue;
            int n = Math.Min(CurrentBar + 1, 5000);
            for (int i = 0; i < n; i++)
            {
                DateTime t = Times[0][i];
                if (t >= ibStart && t <= ibEnd)
                    l = Math.Min(l, Low[i]);
                if (t < ibStart.AddMinutes(-90)) break;
            }
            return l == double.MaxValue ? double.NaN : l;
        }

        private void ComputeRegression(int win, out double center, out double slope, out double sd)
        {
            int n = Math.Min(win, CurrentBar + 1);
            if (n < 10)
            {
                center = Close[0];
                slope = 0;
                sd = TickSize;
                return;
            }

            double sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            for (int i = 0; i < n; i++)
            {
                double x = i;
                double y = Close[i];
                sumX += x; sumY += y; sumXY += x * y; sumXX += x * x;
            }
            double denom = n * sumXX - sumX * sumX;
            slope = denom != 0 ? (n * sumXY - sumX * sumY) / denom : 0;

            double meanX = sumX / n;
            double meanY = sumY / n;
            double intercept = meanY - slope * meanX;
            center = intercept;

            double ss = 0;
            for (int i = 0; i < n; i++)
            {
                double pred = intercept + slope * i;
                double r = Close[i] - pred;
                ss += r * r;
            }
            sd = Math.Sqrt(ss / Math.Max(1, n - 2));
            if (sd < TickSize) sd = TickSize;
        }
    }
}

#region NinjaScript generated code. Neither change nor remove.
namespace NinjaTrader.NinjaScript.Indicators
{
    public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
    {
        private RotationHUD[] cacheRotationHUD;
        public RotationHUD RotationHUD(int chopLen, int chopMin, int adxLen, int adxMax, int regrWin, bool useManualVA, double manualVAH, double manualVAL, double manualPOC, double vAProxyK, int vAProxyLen, string iBStartStr, string iBEndStr, int wRegime, int wLocation, int wBias, int greenMin, int yellowMin, TextPosition badgePosition, bool showLines)
        {
            return RotationHUD(Input, chopLen, chopMin, adxLen, adxMax, regrWin, useManualVA, manualVAH, manualVAL, manualPOC, vAProxyK, vAProxyLen, iBStartStr, iBEndStr, wRegime, wLocation, wBias, greenMin, yellowMin, badgePosition, showLines);
        }

        public RotationHUD RotationHUD(ISeries<double> input, int chopLen, int chopMin, int adxLen, int adxMax, int regrWin, bool useManualVA, double manualVAH, double manualVAL, double manualPOC, double vAProxyK, int vAProxyLen, string iBStartStr, string iBEndStr, int wRegime, int wLocation, int wBias, int greenMin, int yellowMin, TextPosition badgePosition, bool showLines)
        {
            if (cacheRotationHUD != null)
                for (int idx = 0; idx < cacheRotationHUD.Length; idx++)
                    if (cacheRotationHUD[idx] != null && cacheRotationHUD[idx].ChopLen == chopLen && cacheRotationHUD[idx].ChopMin == chopMin && cacheRotationHUD[idx].AdxLen == adxLen && cacheRotationHUD[idx].AdxMax == adxMax && cacheRotationHUD[idx].RegrWin == regrWin && cacheRotationHUD[idx].UseManualVA == useManualVA && cacheRotationHUD[idx].ManualVAH == manualVAH && cacheRotationHUD[idx].ManualVAL == manualVAL && cacheRotationHUD[idx].ManualPOC == manualPOC && cacheRotationHUD[idx].VAProxyK == vAProxyK && cacheRotationHUD[idx].VAProxyLen == vAProxyLen && cacheRotationHUD[idx].IBStartStr == iBStartStr && cacheRotationHUD[idx].IBEndStr == iBEndStr && cacheRotationHUD[idx].WRegime == wRegime && cacheRotationHUD[idx].WLocation == wLocation && cacheRotationHUD[idx].WBias == wBias && cacheRotationHUD[idx].GreenMin == greenMin && cacheRotationHUD[idx].YellowMin == yellowMin && cacheRotationHUD[idx].BadgePosition == badgePosition && cacheRotationHUD[idx].ShowLines == showLines && cacheRotationHUD[idx].EqualsInput(input))
                        return cacheRotationHUD[idx];
            return CacheIndicator<RotationHUD>(new RotationHUD(){ ChopLen = chopLen, ChopMin = chopMin, AdxLen = adxLen, AdxMax = adxMax, RegrWin = regrWin, UseManualVA = useManualVA, ManualVAH = manualVAH, ManualVAL = manualVAL, ManualPOC = manualPOC, VAProxyK = vAProxyK, VAProxyLen = vAProxyLen, IBStartStr = iBStartStr, IBEndStr = iBEndStr, WRegime = wRegime, WLocation = wLocation, WBias = wBias, GreenMin = greenMin, YellowMin = yellowMin, BadgePosition = badgePosition, ShowLines = showLines }, input, ref cacheRotationHUD);
        }
    }
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
    public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
    {
        public Indicators.RotationHUD RotationHUD(int chopLen, int chopMin, int adxLen, int adxMax, int regrWin, bool useManualVA, double manualVAH, double manualVAL, double manualPOC, double vAProxyK, int vAProxyLen, string iBStartStr, string iBEndStr, int wRegime, int wLocation, int wBias, int greenMin, int yellowMin, TextPosition badgePosition, bool showLines)
        {
            return indicator.RotationHUD(Input, chopLen, chopMin, adxLen, adxMax, regrWin, useManualVA, manualVAH, manualVAL, manualPOC, vAProxyK, vAProxyLen, iBStartStr, iBEndStr, wRegime, wLocation, wBias, greenMin, yellowMin, badgePosition, showLines);
        }

        public Indicators.RotationHUD RotationHUD(ISeries<double> input , int chopLen, int chopMin, int adxLen, int adxMax, int regrWin, bool useManualVA, double manualVAH, double manualVAL, double manualPOC, double vAProxyK, int vAProxyLen, string iBStartStr, string iBEndStr, int wRegime, int wLocation, int wBias, int greenMin, int yellowMin, TextPosition badgePosition, bool showLines)
        {
            return indicator.RotationHUD(input, chopLen, chopMin, adxLen, adxMax, regrWin, useManualVA, manualVAH, manualVAL, manualPOC, vAProxyK, vAProxyLen, iBStartStr, iBEndStr, wRegime, wLocation, wBias, greenMin, yellowMin, badgePosition, showLines);
        }
    }
}

namespace NinjaTrader.NinjaScript.Strategies
{
    public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
    {
        public Indicators.RotationHUD RotationHUD(int chopLen, int chopMin, int adxLen, int adxMax, int regrWin, bool useManualVA, double manualVAH, double manualVAL, double manualPOC, double vAProxyK, int vAProxyLen, string iBStartStr, string iBEndStr, int wRegime, int wLocation, int wBias, int greenMin, int yellowMin, TextPosition badgePosition, bool showLines)
        {
            return indicator.RotationHUD(Input, chopLen, chopMin, adxLen, adxMax, regrWin, useManualVA, manualVAH, manualVAL, manualPOC, vAProxyK, vAProxyLen, iBStartStr, iBEndStr, wRegime, wLocation, wBias, greenMin, yellowMin, badgePosition, showLines);
        }

        public Indicators.RotationHUD RotationHUD(ISeries<double> input , int chopLen, int chopMin, int adxLen, int adxMax, int regrWin, bool useManualVA, double manualVAH, double manualVAL, double manualPOC, double vAProxyK, int vAProxyLen, string iBStartStr, string iBEndStr, int wRegime, int wLocation, int wBias, int greenMin, int yellowMin, TextPosition badgePosition, bool showLines)
        {
            return indicator.RotationHUD(input, chopLen, chopMin, adxLen, adxMax, regrWin, useManualVA, manualVAH, manualVAL, manualPOC, vAProxyK, vAProxyLen, iBStartStr, iBEndStr, wRegime, wLocation, wBias, greenMin, yellowMin, badgePosition, showLines);
        }
    }
}
#endregion
